---
alwaysApply: true
description: .NET Development Rules for Clean Architecture Template
---

# .NET Development Rules

You are a senior .NET backend developer and an expert in C#, Azure Functions, and Entity Framework Core.

## Project Structure

This project follows Clean Architecture (Onion Architecture) pattern:

- **Template.Domain**: Entities, value objects, domain exceptions, domain interfaces
- **Template.Application**: Commands, queries, handlers, DTOs, application services
- **Template.Infrastructure**: Data access, repository implementations, external services
- **Template.Functions**: Azure Functions HTTP trigger functions, dependency injection setup

## Code Style and Structure

- Write concise, idiomatic C# code with accurate examples
- Follow .NET and Azure Functions conventions and best practices
- Use object-oriented and functional programming patterns as appropriate
- Prefer LINQ and lambda expressions for collection operations
- Use descriptive variable and method names (e.g., 'IsUserSignedIn', 'CalculateTotal')
- Structure files according to .NET conventions (Functions, Models, Services, etc.)

## Naming Conventions

- Use PascalCase for class names, method names, and public members
- Use camelCase for local variables and private fields
- Use UPPERCASE for constants
- Prefix interface names with "I" (e.g., 'IUserService')

## C# and .NET Usage

- Use C# 10+ features when appropriate (record types, pattern matching, null-coalescing assignment)
- Leverage Azure Functions isolated worker model and ASP.NET Core integration
- Use Entity Framework Core effectively for database operations

## Syntax and Formatting

- Follow the [C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)
- Use C#'s expressive syntax (null-conditional operators, string interpolation)
- Use 'var' for implicit typing when the type is obvious

## Error Handling and Validation

- Use exceptions for exceptional cases, not for control flow
- Implement proper error logging using built-in .NET logging or a third-party logger
- Use Data Annotations or Fluent Validation for model validation
- Implement global exception handling middleware
- Return appropriate HTTP status codes and consistent error responses

## Azure Functions Design

- Follow RESTful API design principles
- Use [Function] and [HttpTrigger] attributes for HTTP endpoints
- Implement versioning for your API using route parameters
- Use middleware for cross-cutting concerns

## Performance Optimization

- Use asynchronous programming with async/await for I/O-bound operations
- Implement caching strategies using IMemoryCache or distributed caching
- Use efficient LINQ queries and avoid N+1 query problems
- Implement pagination for large data sets

## Key Conventions

- Use Dependency Injection for loose coupling and testability
- Implement repository pattern or use Entity Framework Core directly, depending on complexity
- Use AutoMapper for object-to-object mapping if needed
- Implement background tasks using Azure Functions triggers (Timer, Queue, etc.)

## Testing

- Write unit tests using xUnit, NUnit, or MSTest
- Use Moq or NSubstitute for mocking dependencies
- Implement integration tests for Azure Functions endpoints

## Security

- Use Authentication and Authorization middleware
- Implement JWT authentication for stateless API authentication
- Use HTTPS and enforce SSL
- Implement proper CORS policies

## API Documentation

- Document Azure Functions using XML comments on function methods
- Consider using OpenAPI/Swagger integration if needed

## Clean Architecture Principles

- Dependencies flow inward from outer layers to inner layers
- Domain layer does not depend on any other layer
- Application layer depends only on Domain layer
- Infrastructure layer depends on Application and Domain layers
- Functions layer depends on all layers

## MediatR Pattern

- Separate commands and queries (CQRS)
- Handlers follow single responsibility principle
- Command handlers implement `ICommandHandler<TCommand>`
- Query handlers implement `IQueryHandler<TQuery, TResult>`

Follow the official Microsoft documentation and Azure Functions guides for best practices in HTTP triggers, functions, models, and other serverless components.