---
globs: *Functions/*.cs,*Functions*/*.cs
description: Azure Functions API design patterns and conventions
---

# Azure Functions API Design Rules

Defines conventions and best practices for Azure Functions HTTP trigger function design in this project.

## Function Design

### HTTP Trigger Function Implementation
```csharp
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;
using MediatR;

public class UsersFunctions
{
    private readonly IMediator _mediator;

    public UsersFunctions(IMediator mediator)
    {
        _mediator = mediator;
    }

    [Function("GetUsers")]
    public async Task<IActionResult> GetUsers(
        [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "api/users")] HttpRequest req)
    {
        var query = new GetAllUsersQuery();
        var result = await _mediator.Send(query);
        return new OkObjectResult(result);
    }
    
    [Function("GetUser")]
    public async Task<IActionResult> GetUser(
        [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "api/users/{id}")] HttpRequest req,
        int id)
    {
        var query = new GetUserByIdQuery { Id = id };
        var result = await _mediator.Send(query);
        return result != null 
            ? new OkObjectResult(result) 
            : new NotFoundResult();
    }
}
```

## RESTful API Design

### HTTP Method Usage
- `GET`: Retrieve resources
- `POST`: Create resources
- `PUT`: Complete resource update
- `PATCH`: Partial resource update
- `DELETE`: Delete resources

### URL Design
```
GET    /api/users              # Get all users
GET    /api/users/{id}         # Get specific user
POST   /api/users              # Create user
PUT    /api/users/{id}         # Update user
PATCH  /api/users/{id}         # Partial update user
DELETE /api/users/{id}         # Delete user
```

### Nested Resources
```
GET    /api/users/{id}/orders           # Get user's orders
POST   /api/users/{id}/orders           # Create user's order
GET    /api/users/{id}/orders/{orderId} # Get specific order
```

## HTTP Status Codes

### Success Responses
- `200 OK`: Success
- `201 Created`: Resource created successfully
- `204 No Content`: Success (no content)

### Client Errors
- `400 Bad Request`: Invalid request
- `401 Unauthorized`: Authentication required
- `403 Forbidden`: Access denied
- `404 Not Found`: Resource not found
- `409 Conflict`: Conflict
- `422 Unprocessable Entity`: Validation error

### Server Errors
- `500 Internal Server Error`: Internal server error

## Response Format

### Success Response
```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2024-01-01T00:00:00Z"
}
```

### Error Response
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [
      {
        "field": "email",
        "message": "Email is required"
      }
    ]
  }
}
```

### Function Return Types

Use `IActionResult` from `Microsoft.AspNetCore.Mvc` for HTTP responses:
```csharp
return new OkObjectResult(data);      // 200 OK
return new CreatedResult(uri, data); // 201 Created
return new NotFoundResult();          // 404 Not Found
return new BadRequestObjectResult(error); // 400 Bad Request
return new ObjectResult(error) { StatusCode = 500 }; // 500 Internal Server Error
```

### Pagination
```json
{
  "items": [...],
  "totalCount": 100,
  "page": 1,
  "pageSize": 10,
  "totalPages": 10
}
```

## Validation

### Model Validation
```csharp
public class CreateUserCommand : ICommand
{
    [Required]
    [StringLength(100)]
    public string Name { get; set; }
    
    [Required]
    [EmailAddress]
    public string Email { get; set; }
}
```

### Custom Validation
```csharp
public class CreateUserCommandValidator : AbstractValidator<CreateUserCommand>
{
    public CreateUserCommandValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty()
            .MaximumLength(100);
            
        RuleFor(x => x.Email)
            .NotEmpty()
            .EmailAddress();
    }
}
```

## Error Handling

### Exception Handling in Functions
```csharp
[Function("ProcessData")]
public async Task<IActionResult> ProcessData(
    [HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = "api/data")] HttpRequest req)
{
    try
    {
        var command = await DeserializeRequestAsync<CreateDataCommand>(req);
        var result = await _mediator.Send(command);
        return new OkObjectResult(result);
    }
    catch (ValidationException ex)
    {
        _logger.LogWarning(ex, "Validation error");
        return new BadRequestObjectResult(new { error = "Validation failed", details = ex.Message });
    }
    catch (NotFoundException ex)
    {
        _logger.LogWarning(ex, "Resource not found");
        return new NotFoundObjectResult(new { error = "Resource not found" });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unhandled exception");
        return new ObjectResult(new { error = "Internal server error" }) { StatusCode = 500 };
    }
}
```

### Global Exception Middleware (Optional)
Azure Functions isolated worker model supports middleware. You can implement exception handling middleware similar to ASP.NET Core:
```csharp
public class ExceptionHandlingMiddleware : IFunctionsWorkerMiddleware
{
    public async Task Invoke(FunctionContext context, FunctionExecutionDelegate next)
    {
        try
        {
            await next(context);
        }
        catch (Exception ex)
        {
            // Handle exception and update response
            var response = context.GetHttpResponseData();
            if (response != null)
            {
                response.StatusCode = HttpStatusCode.InternalServerError;
                await response.WriteStringAsync(JsonSerializer.Serialize(new { error = ex.Message }));
            }
        }
    }
}
```

## API Versioning

### Versioning Implementation
Use route parameters for API versioning:
```csharp
[Function("GetUsersV1")]
public async Task<IActionResult> GetUsersV1(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "api/v1/users")] HttpRequest req)
{
    // V1 implementation
}

[Function("GetUsersV2")]
public async Task<IActionResult> GetUsersV2(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "api/v2/users")] HttpRequest req)
{
    // V2 implementation
}
```

## Authentication and Authorization

### JWT Authentication
```csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = configuration["Jwt:Issuer"],
            ValidAudience = configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(configuration["Jwt:Key"]))
        };
    });
```

### Authorization Implementation
Use `AuthorizationLevel` parameter in `HttpTrigger` attribute:
```csharp
[Function("GetUsers")]
public async Task<IActionResult> GetUsers(
    [HttpTrigger(AuthorizationLevel.Function, "get", Route = "api/users")] HttpRequest req)
{
    // Requires function key or master key
}

[Function("DeleteUser")]
public async Task<IActionResult> DeleteUser(
    [HttpTrigger(AuthorizationLevel.Admin, "delete", Route = "api/users/{id}")] HttpRequest req,
    int id)
{
    // Requires master key
}

// For custom JWT authentication, check headers manually:
var authHeader = req.Headers["Authorization"].FirstOrDefault();
// Validate token and extract claims
```

## CORS Configuration

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowSpecificOrigins", policy =>
    {
        policy.WithOrigins("https://localhost:3000")
              .AllowAnyHeader()
              .AllowAnyMethod();
    });
});

app.UseCors("AllowSpecificOrigins");
```

## OpenAPI Documentation

### XML Comments for Functions
```csharp
/// <summary>
/// Gets user information
/// </summary>
/// <param name="req">HTTP request</param>
/// <param name="id">User ID</param>
/// <returns>User information</returns>
/// <response code="200">User information retrieved successfully</response>
/// <response code="404">User not found</response>
[Function("GetUser")]
public async Task<IActionResult> GetUser(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "api/users/{id}")] HttpRequest req,
    int id)
{
    // Implementation
}
```

### OpenAPI Integration (Optional)
Azure Functions can integrate with OpenAPI/Swagger using additional packages if needed:
- Microsoft.Azure.WebJobs.Extensions.OpenApi
- Or use Azure API Management for API documentation

## Performance Optimization

### Asynchronous Processing
```csharp
[Function("GetUsers")]
public async Task<IActionResult> GetUsers(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "api/users")] HttpRequest req)
{
    var query = new GetAllUsersQuery();
    var result = await _mediator.Send(query);
    return new OkObjectResult(result);
}
```

### Caching Usage
Azure Functions can use distributed caching or response caching headers:
```csharp
[Function("GetUser")]
public async Task<IActionResult> GetUser(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = "api/users/{id}")] HttpRequest req,
    int id)
{
    // Use IMemoryCache or IDistributedCache for caching
    var cacheKey = $"user_{id}";
    // Implementation with caching
}
```

### Compression
Azure Functions automatically handles compression through HTTP response headers. No additional configuration needed.